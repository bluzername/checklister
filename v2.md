# Checklister V2: Data-Driven Edge Model

## Overview

Transform the current 10-criteria checklist from a "nice UX tool" into a statistically calibrated, data-driven edge estimator with full backtesting, portfolio risk management, and continuous validation.

**Current State:** The `success_probability` in `src/lib/analysis.ts` is simply the sum of 10 equally-weighted 0-10 scores with no statistical calibration. All downstream logic (recommendations, watchlist scoring, trade_type) depends on this unvalidated metric.

**Target State:** A trained, calibrated model that maps features → probability of achieving target R, with backtesting validation, portfolio-level risk controls, and real-time event data.

---

## Architecture Decisions

### Key Files
- [`src/lib/analysis.ts`](src/lib/analysis.ts) - Main analysis pipeline (1127 lines)
- [`src/lib/market-regime/detector.ts`](src/lib/market-regime/detector.ts) - Static regime thresholds
- [`src/lib/multi-timeframe/analyzer.ts`](src/lib/multi-timeframe/analyzer.ts) - MTF alignment logic
- [`src/lib/volume-profile/calculator.ts`](src/lib/volume-profile/calculator.ts) - Volume metrics
- [`src/lib/data-services/sentiment.ts`](src/lib/data-services/sentiment.ts) - LLM-based sentiment (no real-time data)
- [`src/app/portfolio-actions.ts`](src/app/portfolio-actions.ts) - Portfolio management (no position sizing)
- [`src/app/watchlist-actions.ts`](src/app/watchlist-actions.ts) - Watchlist with `isGoodEntry()` logic

### Database Schema (Supabase)
- `watchlists` - User watchlist items
- `portfolios` - User positions with sells tracking
- **New tables needed:** `historical_signals`, `trade_outcomes`, `model_predictions`

---

## Phase 1: Data Infrastructure (Foundation)

**Goal:** Enable historical data storage and retrieval for backtesting and model training.

### 1.1 Historical Signal Storage

Create a system to store analysis results over time:

```typescript
// New table: historical_signals
interface HistoricalSignal {
  id: string;
  ticker: string;
  signal_date: string;
  analysis_result: AnalysisResult; // Full JSON snapshot
  feature_vector: number[]; // Extracted features for ML
  regime: MarketRegime;
  created_at: string;
}
```

### 1.2 Trade Outcome Tracking

```typescript
// New table: trade_outcomes
interface TradeOutcome {
  id: string;
  signal_id: string;
  ticker: string;
  entry_date: string;
  entry_price: number;
  stop_loss: number;
  exit_date?: string;
  exit_price?: number;
  exit_reason: 'STOP_LOSS' | 'TP1' | 'TP2' | 'TP3' | 'TIME_EXIT' | 'MANUAL';
  r_multiple: number; // (exit - entry) / (entry - stop)
  holding_days: number;
  max_adverse_excursion: number;
  max_favorable_excursion: number;
}
```

### 1.3 Universe Definition

Add explicit stock universe filters to `analysis.ts`:

```typescript
interface UniverseFilter {
  min_avg_dollar_volume: number;  // e.g., $5M daily
  min_price: number;              // e.g., $5
  max_price: number;              // e.g., $500
  min_market_cap: number;         // e.g., $500M
  excluded_sectors?: string[];
  excluded_tickers?: string[];
}
```

### 1.4 Scheduled Universe Scanning

Add cron job or scheduled function to scan universe daily:
- Pre-market: Analyze all watchlist + universe candidates
- Store signals with `signal_date`
- Track outcomes over time

**Deliverables:**
- [ ] Supabase migrations for new tables
- [ ] `HistoricalSignalService` class
- [ ] Universe filter configuration
- [ ] Scheduled scanner (Vercel cron or similar)

---

## Phase 2: Backtesting Engine

**Goal:** Build infrastructure to validate strategies with historical data.

### 2.1 Core Backtester

```typescript
// src/lib/backtest/engine.ts
interface BacktestConfig {
  universe: string[];
  startDate: string;
  endDate: string;
  initialCapital: number;
  riskPerTrade: number;          // e.g., 1% of equity
  maxOpenPositions: number;
  entryThreshold: number;        // Min probability to enter
  minRRRatio: number;
  tpRatios: [number, number, number]; // TP1, TP2, TP3 as R multiples
  tpSizes: [number, number, number];  // % to sell at each TP
}

interface BacktestResult {
  totalTrades: number;
  winRate: number;
  averageR: number;
  profitFactor: number;
  sharpeRatio: number;
  sortinoRatio: number;
  maxDrawdown: number;
  calmarRatio: number;
  equityCurve: {date: string; equity: number}[];
  tradeLog: TradeOutcome[];
  performanceByRegime: Record<MarketRegime, PerformanceMetrics>;
  performanceBySector: Record<string, PerformanceMetrics>;
}
```

### 2.2 Realistic Execution Model

```typescript
interface ExecutionModel {
  slippagePercent: number;        // e.g., 0.1%
  commissionPerShare: number;     // e.g., $0.005
  gapHandling: 'SKIP' | 'MARKET'; // What to do if price gaps through stop/TP
  entryMethod: 'MARKET' | 'LIMIT_AT_SUPPORT';
  exitMethod: 'STOP_LIMIT' | 'STOP_MARKET';
}
```

### 2.3 analyzeAtDate Function

Modify `analyzeTicker` to accept optional `asOfDate`:

```typescript
export async function analyzeTicker(
  ticker: string,
  asOfDate?: Date  // If provided, only use data up to this date
): Promise<AnalysisResult>
```

**Deliverables:**
- [ ] `analyzeAtDate` variant of `analyzeTicker`
- [ ] Backtest engine with position simulator
- [ ] Equity curve and metrics calculation
- [ ] Walk-forward validation framework
- [ ] Performance reporting dashboard

---

## Phase 3: Portfolio Risk Management

**Goal:** Implement proper position sizing and exposure controls.

### 3.1 Risk Budget System

```typescript
// src/lib/portfolio/risk-manager.ts
interface RiskBudget {
  maxRiskPerTrade: number;        // e.g., 1% of equity
  maxTotalRisk: number;           // e.g., 6% of equity
  maxPerSector: number;           // e.g., 3% per sector
  maxPerRegime: Record<MarketRegime, number>;
  maxPositions: number;
  correlationLimit?: number;      // Optional: max correlation between positions
}

interface PositionSizeCalculation {
  ticker: string;
  entryPrice: number;
  stopLoss: number;
  equity: number;
  currentExposure: number;
  sectorExposure: Record<string, number>;
  
  recommendedShares: number;
  recommendedDollarValue: number;
  riskDollars: number;
  rejectionReason?: string;       // If position rejected
}
```

### 3.2 Position Sizing Formula

```typescript
function calculatePositionSize(
  equity: number,
  riskPerTrade: number,     // As percentage (e.g., 0.01)
  entryPrice: number,
  stopLoss: number,
  maxPositionPct: number    // From regime thresholds
): number {
  const riskPerUnit = entryPrice - stopLoss;
  const maxRiskDollars = equity * riskPerTrade;
  const maxPositionDollars = equity * maxPositionPct;
  
  const sharesFromRisk = Math.floor(maxRiskDollars / riskPerUnit);
  const sharesFromPosition = Math.floor(maxPositionDollars / entryPrice);
  
  return Math.min(sharesFromRisk, sharesFromPosition);
}
```

### 3.3 Exposure Controls

Modify `analyzePortfolio` to include:
- Total portfolio risk calculation
- Per-sector exposure
- Correlation warnings
- New position feasibility check

**Deliverables:**
- [ ] RiskManager service
- [ ] Position sizing in TradingPlan output
- [ ] Portfolio exposure dashboard
- [ ] Pre-trade risk check API

---

## Phase 4: Trained Probability Model

**Goal:** Replace equal-weight scoring with a calibrated ML model.

### 4.1 Feature Engineering

Extract from current `AnalysisResult`:

```typescript
interface MLFeatureVector {
  // Raw criteria scores (10 features)
  market_condition_score: number;
  sector_condition_score: number;
  company_condition_score: number;
  catalyst_score: number;
  pattern_score: number;
  support_resistance_score: number;
  price_movement_score: number;
  volume_score: number;
  ma_fibonacci_score: number;
  rsi_score: number;
  
  // Additional raw indicators (20+ features)
  rsi_value: number;
  atr_percent: number;
  rvol: number;
  cmf_value: number;
  obv_trend: number;           // Encoded: UP=1, FLAT=0, DOWN=-1
  price_vs_200sma: number;     // As percentage
  price_vs_50sma: number;
  sector_rs_20d: number;
  sector_rs_60d: number;
  vix_level: number;
  spy_above_50sma: boolean;
  golden_cross: boolean;
  rr_ratio: number;
  
  // MTF features
  mtf_daily_score: number;
  mtf_4h_score: number;
  mtf_alignment: number;       // Encoded
  macd_4h_status: number;      // Encoded
  
  // Divergence
  divergence_type: number;     // Encoded
  divergence_strength: number;
  
  // Pattern features
  pattern_type: number;        // Encoded
  gap_percent: number;
  bull_flag_detected: boolean;
  hammer_detected: boolean;
  
  // Regime context
  regime: number;              // Encoded: BULL=2, CHOPPY=1, CRASH=0
  regime_confidence: number;
}
```

### 4.2 Target Definition

```typescript
interface TrainingTarget {
  // Binary classification target
  y_positive_r: boolean;       // True if trade achieved >= +1.5R
  
  // Regression targets (optional)
  final_r: number;             // Actual R achieved
  max_favorable_excursion: number;
  days_to_exit: number;
}
```

### 4.3 Model Architecture

**Phase 4a: Logistic Regression Baseline**
- Simple, interpretable
- Easy to debug
- Provides feature importance

**Phase 4b: Gradient Boosted Trees**
- XGBoost or LightGBM
- Handles non-linear interactions
- Better performance

```typescript
// Model deployment interface
interface EdgeModel {
  predict(features: MLFeatureVector): number;      // Returns probability 0-1
  getFeatureImportance(): Record<string, number>;
  getShapValues(features: MLFeatureVector): Record<string, number>;
}
```

### 4.4 Calibration

- Use isotonic regression or Platt scaling
- Validate with calibration plots
- Ensure predicted probability ≈ actual win rate

### 4.5 Integration

Modify `calculateSuccessProbability` in `analysis.ts`:

```typescript
export function calculateSuccessProbability(
  parameters: AnalysisParameters,
  additionalFeatures: AdditionalFeatures
): number {
  const featureVector = extractFeatures(parameters, additionalFeatures);
  
  // Use trained model instead of sum
  const probability = model.predict(featureVector);
  
  return Math.round(probability * 100 * 10) / 10;
}
```

**Deliverables:**
- [ ] Feature extraction pipeline
- [ ] Training data generation from historical signals
- [ ] Logistic regression baseline model
- [ ] Gradient boosted model (XGBoost)
- [ ] Calibration and validation framework
- [ ] Model serving infrastructure
- [ ] SHAP/feature importance API

---

## Phase 5: Real-Time Event Data

**Goal:** Replace LLM-based sentiment with structured, real-time event data.

### 5.1 Data Sources

Replace `src/lib/data-services/sentiment.ts` with actual data feeds:

```typescript
interface NewsDataSource {
  provider: 'benzinga' | 'polygon' | 'newsapi' | 'alphavantage';
  
  getRecentNews(ticker: string, days: number): Promise<NewsItem[]>;
  getEarningsCalendar(ticker: string): Promise<EarningsEvent | null>;
  getRatingsChanges(ticker: string, days: number): Promise<RatingChange[]>;
}

interface NewsItem {
  headline: string;
  published_at: string;
  source: string;
  sentiment_score?: number;     // If provided by API
  event_type?: string;          // 'earnings', 'merger', 'fda', etc.
  relevance_score: number;
}
```

### 5.2 Event Feature Extraction

```typescript
interface EventFeatures {
  // Counts in rolling window
  positive_news_count_10d: number;
  negative_news_count_10d: number;
  
  // Decay-weighted sentiment
  decayed_sentiment_score: number;
  
  // Discrete events
  days_since_earnings: number | null;
  earnings_surprise_percent: number | null;
  has_upcoming_earnings_7d: boolean;
  
  // Analyst activity
  recent_upgrade: boolean;
  recent_downgrade: boolean;
  
  // Event-driven edge (from separate model)
  event_edge_score: number;
  event_risk_score: number;
}
```

### 5.3 Keep LLM for UX

Use Claude only for human-readable summaries, not numeric scoring:

```typescript
async function generateSummary(
  ticker: string,
  newsItems: NewsItem[],
  eventFeatures: EventFeatures
): Promise<string> {
  // Use Claude to generate natural language summary
  // But don't use for numeric scoring
}
```

**Deliverables:**
- [ ] News API integration (Benzinga/Polygon)
- [ ] Event feature extraction
- [ ] Earnings calendar integration
- [ ] Analyst ratings tracking
- [ ] LLM summary generation (UX only)

---

## Phase 6: Learned Regime & MTF

**Goal:** Replace static thresholds with data-driven regime detection and MTF weighting.

### 6.1 Statistical Regime Labeling

Options:
1. **Hidden Markov Model (HMM)** on SPY + VIX features
2. **K-means clustering** on volatility/trend features
3. **Supervised labeling** based on forward returns

```typescript
interface LearnedRegime {
  regime: 'BULL' | 'CHOPPY' | 'CRASH' | 'RECOVERY';
  confidence: number;
  features: {
    realized_vol_20d: number;
    trend_slope_50d: number;
    drawdown_from_high: number;
    vix_percentile: number;
    breadth_indicator: number;  // % of stocks above 200 SMA
  };
}
```

### 6.2 Regime-Specific Models

Option A: Single model with regime features + interactions
Option B: Separate models per regime, ensemble

### 6.3 MTF as Features

Instead of binary gating, treat MTF as continuous features:
- `daily_score` (0-10)
- `hour4_score` (0-10)
- `alignment_category` (encoded)

Let the ML model learn the optimal weighting per regime.

**Deliverables:**
- [ ] Regime clustering/HMM implementation
- [ ] Regime labeling validation
- [ ] Regime-conditioned model training
- [ ] MTF feature integration

---

## Phase 7: Exit Optimization

**Goal:** Replace hard-coded TP/SL with empirically validated exits.

### 7.1 Exit Strategy Backtesting

Test multiple exit policies:

```typescript
interface ExitPolicy {
  name: string;
  stopType: 'FIXED_R' | 'ATR_TRAILING' | 'CHANDELIER' | 'SWING_LOW';
  stopParams: Record<string, number>;
  
  takeProfitType: 'FIXED_R' | 'TRAILING' | 'TIME_BASED' | 'SIGNAL_BASED';
  takeProfitParams: Record<string, number>;
  
  maxHoldingDays?: number;
}

// Example policies to test
const exitPolicies: ExitPolicy[] = [
  {
    name: 'Current (Fixed R)',
    stopType: 'FIXED_R',
    stopParams: { swingLowBuffer: 0.01 },
    takeProfitType: 'FIXED_R',
    takeProfitParams: { tp1: 1.5, tp2: 2.5, tp3: 4.0 },
  },
  {
    name: 'ATR Trailing',
    stopType: 'ATR_TRAILING',
    stopParams: { atrMultiple: 2.5 },
    takeProfitType: 'TRAILING',
    takeProfitParams: { trailAfterR: 1.0, trailPercent: 0.15 },
  },
  {
    name: 'Chandelier Exit',
    stopType: 'CHANDELIER',
    stopParams: { period: 22, atrMultiple: 3.0 },
    takeProfitType: 'SIGNAL_BASED',
    takeProfitParams: {},
  },
];
```

### 7.2 Dynamic TP Selection

Based on empirical max favorable excursion distribution:

```typescript
function calculateOptimalTPs(
  ticker: string,
  regime: MarketRegime,
  atrPercent: number
): TPLevels {
  // Look up historical MFE distribution for similar setups
  // Set TPs at empirical percentiles (e.g., 50th, 75th, 90th)
}
```

**Deliverables:**
- [ ] Exit policy framework
- [ ] Multiple exit strategy backtests
- [ ] MFE/MAE analysis
- [ ] Dynamic TP calculation

---

## Phase 8: Cross-Sectional Ranking

**Goal:** Move from absolute thresholds to relative ranking.

### 8.1 Daily Ranking Engine

```typescript
interface RankedSetup {
  ticker: string;
  probability: number;
  expectedR: number;           // p_win * avg_win_R - (1-p_win) * avg_loss_R
  sectorRank: number;          // Rank within sector
  overallRank: number;         // Rank across universe
  
  // Only consider top N for trading
  isTopTier: boolean;
}

async function rankUniverse(
  universe: string[],
  maxPositions: number
): Promise<RankedSetup[]> {
  const analyses = await Promise.all(
    universe.map(ticker => analyzeTicker(ticker))
  );
  
  // Calculate expected R for each
  const ranked = analyses
    .map(a => ({
      ticker: a.ticker,
      probability: a.success_probability / 100,
      expectedR: calculateExpectedR(a),
    }))
    .sort((a, b) => b.expectedR - a.expectedR);
  
  // Mark top tier
  return ranked.map((r, i) => ({
    ...r,
    overallRank: i + 1,
    isTopTier: i < maxPositions * 2,
  }));
}
```

### 8.2 Sector-Relative Selection

Within each sector, allocate to top-ranked setups:

```typescript
function allocateBySector(
  rankedSetups: RankedSetup[],
  maxPerSector: number
): string[] {
  const bySector = groupBy(rankedSetups, s => s.sector);
  
  const selected: string[] = [];
  for (const [sector, setups] of Object.entries(bySector)) {
    const topInSector = setups
      .filter(s => s.isTopTier)
      .slice(0, maxPerSector);
    selected.push(...topInSector.map(s => s.ticker));
  }
  
  return selected;
}
```

**Deliverables:**
- [ ] Daily ranking job
- [ ] Expected R calculation
- [ ] Sector allocation logic
- [ ] Ranking dashboard in UI

---

## Phase 9: Continuous Validation

**Goal:** Track model performance and detect drift.

### 9.1 Prediction Logging

```typescript
// Log every prediction for later validation
interface PredictionLog {
  prediction_id: string;
  ticker: string;
  prediction_date: string;
  predicted_probability: number;
  feature_vector: MLFeatureVector;
  regime: MarketRegime;
  model_version: string;
  
  // Filled in later
  actual_outcome?: boolean;
  actual_r?: number;
}
```

### 9.2 Calibration Monitoring

```typescript
interface CalibrationMetrics {
  bucket: string;              // e.g., "70-80%"
  predicted_avg: number;
  actual_rate: number;
  count: number;
  brier_score: number;
}

function calculateCalibration(
  predictions: PredictionLog[]
): CalibrationMetrics[] {
  // Group by probability bucket, calculate actual hit rate
}
```

### 9.3 Feature Importance Drift

Track if feature distributions or importances change over time.

### 9.4 Performance Dashboard

Add to `/admin` route:
- Calibration plot
- Performance by probability bucket
- Performance by criterion score decile
- Performance by regime/sector
- Model drift indicators

**Deliverables:**
- [ ] Prediction logging table
- [ ] Calibration calculation job
- [ ] Performance attribution by feature
- [ ] Admin dashboard expansion
- [ ] Alerting for significant drift

---

## Phase 10: Refinements

### 10.1 Data Sufficiency Flags

```typescript
interface DataSufficiency {
  hasEnoughHistory: boolean;
  minimumBarsAvailable: number;
  fundamentalsAvailable: boolean;
  newsDataAvailable: boolean;
  
  // If insufficient, cap probability
  probabilityCap?: number;
}
```

### 10.2 Entry Timing Optimization

Add intraday confirmation requirements:
- Lower timeframe reversal signals
- Volume spike on entry bar
- Time filters (avoid Friday close, earnings week)

### 10.3 Setup Validity Period

```typescript
interface SetupValidity {
  valid_from: string;
  valid_until: string;          // e.g., 3-5 days
  invalidation_price: number;   // Price that invalidates setup
  required_confirmation: string; // e.g., "Break above prior day high"
}
```

### 10.4 Fundamental Factors

Expand `CRITERION 3`:
- Earnings revisions momentum
- Forward P/E vs sector
- Quality factor (ROE, margins)
- Growth factor (revenue acceleration)

### 10.5 Options Data (if available)

- Implied volatility rank
- Put/call skew
- Unusual options activity

**Deliverables:**
- [ ] Data sufficiency checks
- [ ] Entry timing rules
- [ ] Setup validity tracking
- [ ] Expanded fundamentals
- [ ] Options data integration (optional)

---

## Implementation Order (Recommended)

| Phase | Priority | Effort | Impact | Dependencies |
|-------|----------|--------|--------|--------------|
| 1 - Data Infrastructure | Critical | Medium | High | None |
| 3 - Portfolio Risk | High | Low | High | None |
| 2 - Backtesting | High | High | Critical | Phase 1 |
| 4 - ML Model | High | High | Critical | Phases 1, 2 |
| 7 - Exit Optimization | Medium | Medium | High | Phase 2 |
| 5 - Event Data | Medium | Medium | Medium | None |
| 8 - Cross-Sectional | Medium | Low | High | Phase 4 |
| 6 - Learned Regime | Medium | High | Medium | Phase 4 |
| 9 - Validation | Medium | Medium | Critical | Phase 4 |
| 10 - Refinements | Low | Variable | Variable | Various |

**Recommended MVP Path:**
1. Phase 1 (partial) → Phase 3 → Phase 2 (basic) → Phase 4 (logistic baseline)
2. Then iterate: improve model, add features, expand backtesting

---

## Progress Tracking

### Phase 1: Data Infrastructure
- [ ] **1.1** Create `historical_signals` table migration
- [ ] **1.2** Create `trade_outcomes` table migration
- [ ] **1.3** Implement `HistoricalSignalService`
- [ ] **1.4** Add universe filter configuration
- [ ] **1.5** Implement scheduled scanner (Vercel cron)
- [ ] **1.6** Add `analyzeAtDate` function variant

### Phase 2: Backtesting Engine
- [ ] **2.1** Core backtest engine structure
- [ ] **2.2** Position simulator with partial exits
- [ ] **2.3** Execution model (slippage, commissions)
- [ ] **2.4** Metrics calculation (Sharpe, DD, etc.)
- [ ] **2.5** Walk-forward validation
- [ ] **2.6** Backtest results dashboard

### Phase 3: Portfolio Risk Management
- [ ] **3.1** RiskManager service
- [ ] **3.2** Position sizing formula
- [ ] **3.3** Exposure tracking (total, per-sector)
- [ ] **3.4** Pre-trade risk check
- [ ] **3.5** Update TradingPlan with `recommended_shares`
- [ ] **3.6** Portfolio exposure UI

### Phase 4: Trained Probability Model
- [ ] **4.1** Feature extraction pipeline
- [ ] **4.2** Training data generation
- [ ] **4.3** Logistic regression baseline
- [ ] **4.4** Gradient boosted model (XGBoost)
- [ ] **4.5** Calibration framework
- [ ] **4.6** Model serving integration
- [ ] **4.7** SHAP feature importance API

### Phase 5: Real-Time Event Data
- [ ] **5.1** News API integration
- [ ] **5.2** Event feature extraction
- [ ] **5.3** Earnings calendar integration
- [ ] **5.4** Analyst ratings tracking
- [ ] **5.5** Keep LLM for summaries only

### Phase 6: Learned Regime & MTF
- [ ] **6.1** HMM/clustering for regime
- [ ] **6.2** Regime validation
- [ ] **6.3** Regime-specific model tuning
- [ ] **6.4** MTF as features (not gates)

### Phase 7: Exit Optimization
- [ ] **7.1** Exit policy framework
- [ ] **7.2** Multiple strategy backtests
- [ ] **7.3** MFE/MAE analysis
- [ ] **7.4** Dynamic TP calculation

### Phase 8: Cross-Sectional Ranking
- [ ] **8.1** Daily ranking engine
- [ ] **8.2** Expected R calculation
- [ ] **8.3** Sector allocation logic
- [ ] **8.4** Ranking UI

### Phase 9: Continuous Validation
- [ ] **9.1** Prediction logging
- [ ] **9.2** Calibration monitoring
- [ ] **9.3** Feature drift detection
- [ ] **9.4** Performance dashboard

### Phase 10: Refinements
- [ ] **10.1** Data sufficiency flags
- [ ] **10.2** Entry timing rules
- [ ] **10.3** Setup validity periods
- [ ] **10.4** Expanded fundamentals
- [ ] **10.5** Options data (optional)

---

## Session Notes

### Session 1 (Current)
- **Date:** 2024-11-29
- **Status:** Plan created
- **Next Steps:** Begin Phase 1 (Data Infrastructure) and Phase 3 (Portfolio Risk)

### Session 2
- **Date:** _TBD_
- **Status:** _TBD_
- **Completed:** _TBD_
- **Next Steps:** _TBD_

### Session 3
- **Date:** _TBD_
- **Status:** _TBD_
- **Completed:** _TBD_
- **Next Steps:** _TBD_

---

## Technical Notes

### Model Training Considerations
- **Survivorship bias:** Include delisted stocks in historical universe
- **Look-ahead bias:** Ensure features use only data available at signal time
- **Transaction costs:** Include realistic slippage/commission in backtests
- **Sample size:** Need ~500+ trades minimum for reliable statistics
- **Out-of-sample:** Always reserve 20-30% of data for final validation

### Risk Management Principles
- Never risk more than 1% of equity per trade
- Total portfolio heat should stay under 6%
- Scale position sizes with regime (CHOPPY = 0.5x, CRASH = 0.25x)
- Correlation matters: avoid concentrated sector bets

### Key Metrics to Track
- **Win Rate:** Target 45-55% for swing trading
- **Average R:** Target 1.5-2.0R average winner
- **Profit Factor:** Target > 1.5
- **Sharpe Ratio:** Target > 1.0 annualized
- **Max Drawdown:** Cap at 15-20%
- **Calmar Ratio:** Target > 1.0

---

*Last Updated: 2024-11-29*




